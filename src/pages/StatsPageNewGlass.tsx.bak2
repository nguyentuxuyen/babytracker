import React, { useState, useEffect, useMemo } from 'react';
import { Card, Typography, Box, Checkbox, FormControlLabel, Grid, Slider } from '@mui/material';
import { Activity } from '../types';
import { firestore } from '../firebase/firestore';
import { getCurrentUser } from '../firebase/auth';
import { useBaby } from '../contexts/BabyContext';
import { ResponsiveContainer, LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Area, AreaChart } from 'recharts';

interface FilterType {
    period: 'day' | 'week' | 'month' | 'range';
    startDate: Date;
    endDate: Date;
    count?: number; // number of days/weeks/months to show (for non-range periods)
}

interface ChartData {
    date: string;
    label: string;
    feeding: number;
    feedingAmount: number;
    diaper: number;
    urine: number;
    stool: number;
    sleep: number;
    weight?: number;
    height?: number;
    temperature?: number;
}

const StatsPage: React.FC = () => {
    const [currentUser, setCurrentUser] = useState<any>(null);
    const [activities, setActivities] = useState<Activity[]>([]);
    const [loading, setLoading] = useState(true);
    const { baby } = useBaby();
    
    // Filter states
    const [filter, setFilter] = useState<FilterType>({
        period: 'day',
        startDate: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000),
        endDate: new Date()
        ,count: 7
    });

    // Chart visibility states for multi-line chart
    const [chartVisibility, setChartVisibility] = useState({
        feeding: true,
        diaper: true,
        urine: true,
        stool: true
    });

    // Get current user when component mounts
    useEffect(() => {
        const user = getCurrentUser();
        setCurrentUser(user);
    }, []);

    // Load activities from Firebase
    useEffect(() => {
        const loadActivities = async () => {
            if (currentUser?.uid) {
                try {
                    setLoading(true);
                    const userActivities = await firestore.getActivities(currentUser.uid);
                    setActivities(userActivities);
                } catch (error) {
                    console.error('Error loading activities:', error);
                } finally {
                    setLoading(false);
                }
            }
        };

        loadActivities();
    }, [currentUser]);

    // Get period label
    const getPeriodLabel = () => {
        const birthDate = baby?.birthDate ? new Date(baby.birthDate) : null;
        const today = new Date();
        
        switch (filter.period) {
            case 'day':
                {
                    const desired = filter.count || 7;
                    if (birthDate) {
                        const daysSinceBirth = Math.floor((today.getTime() - birthDate.getTime()) / (1000 * 60 * 60 * 24)) + 1;
                        const daysToShow = Math.min(desired, daysSinceBirth);
                        return `Last ${daysToShow} day${daysToShow > 1 ? 's' : ''}`;
                    }
                    return `Last ${desired} day${desired > 1 ? 's' : ''}`;
                }
            case 'week':
                {
                    const desired = filter.count || 4;
                    if (birthDate) {
                        const weeksSinceBirth = Math.floor((today.getTime() - birthDate.getTime()) / (1000 * 60 * 60 * 24 * 7)) + 1;
                        const weeksToShow = Math.min(desired, weeksSinceBirth);
                        return `Last ${weeksToShow} week${weeksToShow > 1 ? 's' : ''}`;
                    }
                    return `Last ${desired} week${desired > 1 ? 's' : ''}`;
                }
            case 'month':
                {
                    const desired = filter.count || 12;
                    if (birthDate) {
                        const monthsSinceBirth = Math.floor((today.getTime() - birthDate.getTime()) / (1000 * 60 * 60 * 24 * 30)) + 1;
                        const monthsToShow = Math.min(desired, monthsSinceBirth);
                        return `Last ${monthsToShow} month${monthsToShow > 1 ? 's' : ''}`;
                    }
                    return `Last ${desired} month${desired > 1 ? 's' : ''}`;
                }
            case 'range':
                return 'Custom range';
            default:
                return '';
        }
    };

    // Process data for charts
    const chartData = useMemo(() => {
        const data: ChartData[] = [];
        const today = new Date();
        const birthDate = baby?.birthDate ? new Date(baby.birthDate) : null;
        
        if (filter.period === 'day') {
            // Last N days (but not before birth date)
            let daysToShow = filter.count || 7;
            
            if (birthDate) {
                const daysSinceBirth = Math.floor((today.getTime() - birthDate.getTime()) / (1000 * 60 * 60 * 24)) + 1;
                daysToShow = Math.min(daysToShow, daysSinceBirth);
            }
            
            for (let i = daysToShow - 1; i >= 0; i--) {
                const dateStart = new Date(today);
                dateStart.setDate(dateStart.getDate() - i);
                dateStart.setHours(0, 0, 0, 0);
                
                // Skip if before birth date
                if (birthDate && dateStart < birthDate) continue;
                
                const dateEnd = new Date(dateStart);
                dateEnd.setHours(23, 59, 59, 999);
                
                const label = dateStart.toLocaleDateString('en-US', { weekday: 'short' });
                
                // Filter and process activities
                const periodActivities = activities.filter(activity => {
                    const activityDate = new Date(activity.timestamp);
                    return activityDate >= dateStart && activityDate <= dateEnd;
                });
                
                const daySummary = periodActivities.reduce((acc, activity) => {
                    switch (activity.type) {
                        case 'feeding':
                            acc.feeding += 1;
                            acc.feedingAmount += activity.details.amount || 0;
                            break;
                        case 'diaper':
                            acc.diaper += 1;
                            if (activity.details.isUrine) acc.urine += 1;
                            if (activity.details?.isStool) acc.stool += 1;
                            break;
                        case 'sleep':
                            acc.sleep += activity.details.duration || 0;
                            break;
                        case 'measurement':
                            if (activity.details.weight) acc.weight = activity.details.weight;
                            if (activity.details.height) acc.height = activity.details.height;
                            if (activity.details.temperature) acc.temperature = activity.details.temperature;
                            break;
                        default:
                            break;
                    }
                    return acc;
                }, {
                    date: label,
                    label: label,
                    feeding: 0,
                    feedingAmount: 0,
                    diaper: 0,
                    urine: 0,
                    stool: 0,
                    sleep: 0,
                    weight: undefined,
                    height: undefined,
                    temperature: undefined
                } as ChartData);
                
                data.push(daySummary);
            }
        } else if (filter.period === 'week') {
            // Last N weeks (but not before birth date)
            let weeksToShow = filter.count || 4;
            
            if (birthDate) {
                const weeksSinceBirth = Math.floor((today.getTime() - birthDate.getTime()) / (1000 * 60 * 60 * 24 * 7)) + 1;
                weeksToShow = Math.min(weeksToShow, weeksSinceBirth);
            }
            
            for (let i = weeksToShow - 1; i >= 0; i--) {
                const dateStart = new Date(today);
                dateStart.setDate(dateStart.getDate() - (7 * i + 6));
                dateStart.setHours(0, 0, 0, 0);
                
                // Skip if week starts before birth date
                if (birthDate && dateStart < birthDate) {
                    if (birthDate) dateStart.setTime(birthDate.getTime());
                }
                
                const dateEnd = new Date(dateStart);
                dateEnd.setDate(dateEnd.getDate() + 6);
                dateEnd.setHours(23, 59, 59, 999);
                
                const label = `Week ${weeksToShow - i}`;
                
                // Filter and process activities
                const periodActivities = activities.filter(activity => {
                    const activityDate = new Date(activity.timestamp);
                    return activityDate >= dateStart && activityDate <= dateEnd;
                });
                
                const weekSummary = periodActivities.reduce((acc, activity) => {
                    switch (activity.type) {
                        case 'feeding':
                            acc.feeding += 1;
                            acc.feedingAmount += activity.details.amount || 0;
                            break;
                        case 'diaper':
                            acc.diaper += 1;
                            if (activity.details.isUrine) acc.urine += 1;
                            if (activity.details?.isStool) acc.stool += 1;
                            break;
                        case 'sleep':
                            acc.sleep += activity.details.duration || 0;
                            break;
                        case 'measurement':
                            if (activity.details.weight) acc.weight = activity.details.weight;
                            if (activity.details.height) acc.height = activity.details.height;
                            if (activity.details.temperature) acc.temperature = activity.details.temperature;
                            break;
                        default:
                            break;
                    }
                    return acc;
                }, {
                    date: label,
                    label: label,
                    feeding: 0,
                    feedingAmount: 0,
                    diaper: 0,
                    urine: 0,
                    stool: 0,
                    sleep: 0,
                    weight: undefined,
                    height: undefined,
                    temperature: undefined
                } as ChartData);
                
                data.push(weekSummary);
            }
        } else if (filter.period === 'month') {
            // Last N months (but not before birth date)
            let monthsToShow = filter.count || 12;
            
            if (birthDate) {
                const monthsSinceBirth = Math.floor((today.getTime() - birthDate.getTime()) / (1000 * 60 * 60 * 24 * 30)) + 1;
                monthsToShow = Math.min(monthsToShow, monthsSinceBirth);
            }
            
            for (let i = monthsToShow - 1; i >= 0; i--) {
                const dateStart = new Date(today);
                dateStart.setMonth(dateStart.getMonth() - i);
                dateStart.setDate(1);
                dateStart.setHours(0, 0, 0, 0);
                
                // Skip if month is before birth date
                if (birthDate) {
                    const monthStart = new Date(dateStart);
                    if (monthStart < birthDate) {
                        // If this month contains birth date, start from birth date
                        const monthEnd = new Date(dateStart);
                        monthEnd.setMonth(monthEnd.getMonth() + 1);
                        monthEnd.setDate(0);
                        
                        if (birthDate <= monthEnd) {
                            dateStart.setTime(birthDate.getTime());
                        } else {
                            continue; // Skip this month entirely
                        }
                    }
                }
                
                const dateEnd = new Date(dateStart);
                dateEnd.setMonth(dateEnd.getMonth() + 1);
                dateEnd.setDate(0);
                dateEnd.setHours(23, 59, 59, 999);
                
                const label = dateStart.toLocaleDateString('en-US', { month: 'short' });
                
                // Filter and process activities
                const periodActivities = activities.filter(activity => {
                    const activityDate = new Date(activity.timestamp);
                    return activityDate >= dateStart && activityDate <= dateEnd;
                });
                
                const monthSummary = periodActivities.reduce((acc, activity) => {
                    switch (activity.type) {
                        case 'feeding':
                            acc.feeding += 1;
                            acc.feedingAmount += activity.details.amount || 0;
                            break;
                        case 'diaper':
                            acc.diaper += 1;
                            if (activity.details.isUrine) acc.urine += 1;
                            if (activity.details?.isStool) acc.stool += 1;
                            break;
                        case 'sleep':
                            acc.sleep += activity.details.duration || 0;
                            break;
                        case 'measurement':
                            if (activity.details.weight) acc.weight = activity.details.weight;
                            if (activity.details.height) acc.height = activity.details.height;
                            if (activity.details.temperature) acc.temperature = activity.details.temperature;
                            break;
                        default:
                            break;
                    }
                    return acc;
                }, {
                    date: label,
                    label: label,
                    feeding: 0,
                    feedingAmount: 0,
                    diaper: 0,
                    urine: 0,
                    stool: 0,
                    sleep: 0,
                    weight: undefined,
                    height: undefined,
                    temperature: undefined
                } as ChartData);
                
                data.push(monthSummary);
            }
        } else {
            // Range: custom date range (but not before birth date)
            const start = new Date(filter.startDate);
            const end = new Date(filter.endDate);
            
            // Adjust start date if it's before birth date
            const actualStart = birthDate && start < birthDate ? new Date(birthDate) : start;
            const diffDays = Math.floor((end.getTime() - actualStart.getTime()) / (1000 * 60 * 60 * 24));
            
            for (let i = 0; i <= Math.min(diffDays, 30); i++) {
                const dateStart = new Date(actualStart);
                dateStart.setDate(dateStart.getDate() + i);
                dateStart.setHours(0, 0, 0, 0);
                
                // Skip if before birth date
                if (birthDate && dateStart < birthDate) continue;
                
                const dateEnd = new Date(dateStart);
                dateEnd.setHours(23, 59, 59, 999);
                
                const label = dateStart.toLocaleDateString('vi-VN', { day: '2-digit', month: '2-digit' });
                
                // Filter and process activities
                const periodActivities = activities.filter(activity => {
                    const activityDate = new Date(activity.timestamp);
                    return activityDate >= dateStart && activityDate <= dateEnd;
                });
                
                const daySummary = periodActivities.reduce((acc, activity) => {
                    switch (activity.type) {
                        case 'feeding':
                            acc.feeding += 1;
                            acc.feedingAmount += activity.details.amount || 0;
                            break;
                        case 'diaper':
                            acc.diaper += 1;
                            if (activity.details.isUrine) acc.urine += 1;
                            if (activity.details?.isStool) acc.stool += 1;
                            break;
                        case 'sleep':
                            acc.sleep += activity.details.duration || 0;
                            break;
                        case 'measurement':
                            if (activity.details.weight) acc.weight = activity.details.weight;
                            if (activity.details.height) acc.height = activity.details.height;
                            if (activity.details.temperature) acc.temperature = activity.details.temperature;
                            break;
                        default:
                            break;
                    }
                    return acc;
                }, {
                    date: label,
                    label: label,
                    feeding: 0,
                    feedingAmount: 0,
                    diaper: 0,
                    urine: 0,
                    stool: 0,
                    sleep: 0,
                    weight: undefined,
                    height: undefined,
                    temperature: undefined
                } as ChartData);
                
                data.push(daySummary);
            }
        }
        
        return data;
    }, [activities, filter, baby?.birthDate]);

    // Calculate aggregates for summary cards
    const totalMilk = useMemo(() => {
        return chartData.reduce((sum, day) => sum + day.feedingAmount, 0);
    }, [chartData]);

    const totalSleep = useMemo(() => {
        return chartData.reduce((sum, day) => sum + day.sleep, 0);
    }, [chartData]);

    // Compute slider limits based on baby's birth date so user cannot select ranges before birth
    const sliderLimits = useMemo(() => {
        const today = new Date();
        if (!baby?.birthDate) {
            return { dayMax: 90, weekMax: 52, monthMax: 36 };
        }
        const birth = new Date(baby.birthDate);
        const daysSinceBirth = Math.max(1, Math.floor((today.getTime() - birth.getTime()) / (1000 * 60 * 60 * 24)) + 1);
        const weeksSinceBirth = Math.max(1, Math.floor(daysSinceBirth / 7));
        const monthsSinceBirth = Math.max(1, Math.floor((today.getTime() - birth.getTime()) / (1000 * 60 * 60 * 24 * 30)) + 1);

        return {
            dayMax: Math.min(90, daysSinceBirth),
            weekMax: Math.min(52, weeksSinceBirth),
            monthMax: Math.min(36, monthsSinceBirth)
        };
    }, [baby?.birthDate]);

    // Clamp filter.count to the computed slider max when period or birthDate changes
    useEffect(() => {
        const maxForPeriod = filter.period === 'day' ? sliderLimits.dayMax : filter.period === 'week' ? sliderLimits.weekMax : sliderLimits.monthMax;
        if ((filter.count || 0) > maxForPeriod) {
            setFilter(prev => ({ ...prev, count: maxForPeriod }));
        }
    }, [filter.period, sliderLimits.dayMax, sliderLimits.weekMax, sliderLimits.monthMax, filter.count]);

    const latestMeasurement = useMemo(() => {
        const withMeasurements = chartData.filter(d => d.weight || d.height);
        return withMeasurements[withMeasurements.length - 1];
    }, [chartData]);

    const handlePeriodChange = (period: 'day' | 'week' | 'month' | 'range') => {
        setFilter(prev => ({
            ...prev,
            period
        }));
    };

    const toggleChartLine = (dataKey: string) => {
        setChartVisibility(prev => ({
            ...prev,
            [dataKey]: !(prev as any)[dataKey]
        }));
    };

    if (loading) {
        return (
            <Box sx={{ minHeight: '100vh', display: 'flex', alignItems: 'center', justifyContent: 'center', fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif' }}>
                <Box sx={{ textAlign: 'center' }}>
                    <Box sx={{ fontSize: 48, mb: 2 }}>üìä</Box>
                    <Typography color="text.primary" fontSize={16}>ƒêang t·∫£i th·ªëng k√™...</Typography>
                </Box>
            </Box>
        );
    }

    return (
        <Box sx={{
            minHeight: '100vh',
            bgcolor: '#f6f7f8',
            p: 0,
            fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
        }}>
            {/* Main Content */}
            <Box sx={{ px: { xs: 2, sm: 3 }, py: 2 }}>
                {/* Period Selector Tabs */}
                    <Box sx={{ mb: 3 }}>
                        <Box sx={{
                            display: 'flex',
                            gap: 0.5,
                            p: 0.5,
                            bgcolor: '#ffffff',
                            borderRadius: '12px',
                            boxShadow: '0 1px 3px rgba(0, 0, 0, 0.04)',
                            border: '1px solid #e5e7eb'
                        }}>
                        {[
                            { key: 'day', label: 'Day' },
                            { key: 'week', label: 'Week' },
                            { key: 'month', label: 'Month' },
                            { key: 'range', label: 'Range' }
                        ].map(period => (
                            <Box
                                key={period.key}
                                onClick={() => handlePeriodChange(period.key as 'day' | 'week' | 'month' | 'range')}
                                sx={{
                                    flex: 1,
                                    py: 1,
                                    px: 2,
                                    textAlign: 'center',
                                    fontSize: '14px',
                                    fontWeight: 600,
                                    borderRadius: '8px',
                                    cursor: 'pointer',
                                    transition: 'all 0.2s',
                                    bgcolor: filter.period === period.key ? '#13a4ec' : 'transparent',
                                    color: filter.period === period.key ? '#ffffff' : '#6b7f8a',
                                    '&:hover': {
                                        bgcolor: filter.period === period.key ? '#13a4ec' : 'rgba(19, 164, 236, 0.1)'
                                    }
                                }}
                            >
                                {period.label}
                            </Box>
                        ))}
                        {/* slider is shown in a dedicated card below */}
                    </Box>
                </Box>

                {/* Date Range Picker - Show when Range is selected */}
                {filter.period === 'range' && (
                    <Box sx={{ 
                        mb: 3, 
                        bgcolor: '#ffffff', 
                        borderRadius: '16px', 
                        p: 3,
                        border: '1px solid #e5e7eb',
                        boxShadow: '0 1px 3px rgba(0, 0, 0, 0.04)'
                    }}>
                        <Typography sx={{ fontSize: '16px', fontWeight: 600, color: '#101c22', mb: 2 }}>
                            Select Date Range
                        </Typography>
                        
                        <Grid container spacing={3}>
                            {/* Start Date */}
                            <Grid item xs={12} sm={6}>
                                <Box>
                                    <Typography sx={{ fontSize: '14px', fontWeight: 500, color: '#6b7f8a', mb: 1 }}>
                                        Start Date
                                    </Typography>
                                    <input
                                        type="date"
                                        value={filter.startDate.toISOString().split('T')[0]}
                                        min={baby?.birthDate ? new Date(baby.birthDate).toISOString().split('T')[0] : undefined}
                                        max={filter.endDate.toISOString().split('T')[0]}
                                        onChange={(e) => {
                                            const newStartDate = new Date(e.target.value);
                                            const birthDate = baby?.birthDate ? new Date(baby.birthDate) : null;
                                            
                                            // Ensure start date is not before birth date
                                            if (birthDate && newStartDate < birthDate) {
                                                return;
                                            }
                                            
                                            setFilter({
                                                ...filter,
                                                startDate: newStartDate
                                            });
                                        }}
                                        style={{
                                            width: '100%',
                                            padding: '12px 16px',
                                            fontSize: '14px',
                                            border: '1px solid #e5e7eb',
                                            borderRadius: '12px',
                                            color: '#101c22',
                                            fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
                                            cursor: 'pointer'
                                        }}
                                    />
                                </Box>
                            </Grid>
                            
                            {/* End Date */}
                            <Grid item xs={12} sm={6}>
                                <Box>
                                    <Typography sx={{ fontSize: '14px', fontWeight: 500, color: '#6b7f8a', mb: 1 }}>
                                        End Date
                                    </Typography>
                                    <input
                                        type="date"
                                        value={filter.endDate.toISOString().split('T')[0]}
                                        min={filter.startDate.toISOString().split('T')[0]}
                                        max={new Date().toISOString().split('T')[0]}
                                        onChange={(e) => {
                                            const newEndDate = new Date(e.target.value);
                                            setFilter({
                                                ...filter,
                                                endDate: newEndDate
                                            });
                                        }}
                                        style={{
                                            width: '100%',
                                            padding: '12px 16px',
                                            fontSize: '14px',
                                            border: '1px solid #e5e7eb',
                                            borderRadius: '12px',
                                            color: '#101c22',
                                            fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
                                            cursor: 'pointer'
                                        }}
                                    />
                                </Box>
                            </Grid>
                        </Grid>
                        
                        {/* Info text */}
                        <Box sx={{ mt: 2, display: 'flex', alignItems: 'center', gap: 1 }}>
                            <svg width="16" height="16" viewBox="0 0 256 256" fill="#6b7f8a">
                                <path d="M128,24A104,104,0,1,0,232,128,104.11,104.11,0,0,0,128,24Zm0,192a88,88,0,1,1,88-88A88.1,88.1,0,0,1,128,216Zm16-40a8,8,0,0,1-8,8,16,16,0,0,1-16-16V128a8,8,0,0,1,0-16,16,16,0,0,1,16,16v40A8,8,0,0,1,144,176ZM112,84a12,12,0,1,1,12,12A12,12,0,0,1,112,84Z"></path>
                            </svg>
                            <Typography sx={{ fontSize: '13px', color: '#6b7f8a' }}>
                                {baby?.birthDate 
                                    ? `Date range limited from ${new Date(baby.birthDate).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })} (birth date) to today`
                                    : 'Select a custom date range to view statistics'
                                }
                            </Typography>
                        </Box>
                    </Box>
                )}

                {/* Charts Grid */}
                {/* Slider Card for custom range */}
                {filter.period !== 'range' && (
                    <Box sx={{ mb: 3 }}>
                        <Card sx={{ p: 2, borderRadius: '12px', bgcolor: '#ffffff', border: '1px solid #e5e7eb' }}>
                            {/* Title + optional subtitle */}
                            <Box>
                                <Typography
                                    noWrap
                                    sx={{
                                        fontSize: 14,
                                        fontWeight: 600,
                                        whiteSpace: 'nowrap',
                                        overflow: 'hidden',
                                        textOverflow: 'ellipsis'
                                    }}
                                >
                                    Adjust range
                                </Typography>
                                {/* optional helper text (kept small) */}
                                <Typography sx={{ fontSize: 12, color: '#6b7f8a', mt: 0.5 }}>
                                    Use the slider to adjust how many {filter.period === 'day' ? 'days' : filter.period === 'week' ? 'weeks' : 'months'} to display
                                </Typography>
                            </Box>

                            {/* Slider placed below the title to avoid clipping on small screens */}
                            <Box sx={{ display: 'flex', alignItems: 'center', gap: 2, mt: 2 }}>
                                <Box sx={{ flex: 1, minWidth: 0 }}>
                                    <Slider
                                        sx={{ width: '100%' }}
                                        value={filter.count || (filter.period === 'day' ? 7 : filter.period === 'week' ? 4 : 12)}
                                        onChange={(_, value) => {
                                            const v = Array.isArray(value) ? value[0] : (value as number);
                                            setFilter(prev => ({ ...prev, count: v }));
                                        }}
                                        min={filter.period === 'day' ? Math.min(3, sliderLimits.dayMax) : filter.period === 'week' ? 1 : 1}
                                        max={filter.period === 'day' ? sliderLimits.dayMax : filter.period === 'week' ? sliderLimits.weekMax : sliderLimits.monthMax}
                                        step={1}
                                        valueLabelDisplay="auto"
                                    />
                                </Box>

                                <Box sx={{ ml: 1, flex: '0 0 auto' }}>
                                    <Typography sx={{ fontSize: 13, fontWeight: 600 }}>
                                        {filter.count || (filter.period === 'day' ? 7 : filter.period === 'week' ? 4 : 12)}
                                    </Typography>
                                </Box>
                            </Box>
                        </Card>
                    </Box>
                )}

                <Grid container spacing={3}>
                    {/* Daily Activities Multi-line Chart - Spans 2 columns on sm and up */}
                    <Grid item xs={12} sm={12} lg={8}>
                        <Card sx={{
                            bgcolor: '#ffffff',
                            borderRadius: '16px',
                            border: '1px solid #e5e7eb',
                            boxShadow: 'none',
                            p: 3
                        }}>
                            <Typography sx={{ fontSize: '16px', fontWeight: 600, color: '#101c22', mb: 0.5 }}>
                                Daily Activities
                            </Typography>
                            <Typography sx={{ fontSize: '14px', color: '#6b7f8a', mb: 3 }}>
                                {getPeriodLabel()}
                            </Typography>

                            {/* Chart Area */}
                            <Box sx={{ minHeight: '250px', position: 'relative', mb: 3 }}>
                                <ResponsiveContainer width="100%" height={250}>
                                    <LineChart data={chartData} margin={{ top: 10, right: 20, left: -10, bottom: 5 }}>
                                        <CartesianGrid strokeDasharray="3 3" stroke="#e5e7eb" />
                                        <XAxis 
                                            dataKey="label" 
                                            tick={{ fontSize: 12, fontWeight: 700, fill: '#6b7f8a' }}
                                            axisLine={false}
                                            tickLine={false}
                                        />
                                        <YAxis 
                                            tick={{ fontSize: 12, fill: '#6b7f8a' }}
                                            axisLine={false}
                                            tickLine={false}
                                            width={35}
                                        />
                                        <Tooltip 
                                            contentStyle={{
                                                backgroundColor: '#ffffff',
                                                border: '1px solid #e5e7eb',
                                                borderRadius: '8px',
                                                fontSize: '12px'
                                            }}
                                        />
                                        {chartVisibility.feeding && (
                                            <Line 
                                                type="monotone" 
                                                dataKey="feeding" 
                                                stroke="#13a4ec" 
                                                strokeWidth={3}
                                                dot={false}
                                                strokeLinecap="round"
                                            />
                                        )}
                                        {chartVisibility.diaper && (
                                            <Line 
                                                type="monotone" 
                                                dataKey="diaper" 
                                                stroke="#f59e0b" 
                                                strokeWidth={3}
                                                dot={false}
                                                strokeLinecap="round"
                                            />
                                        )}
                                        {chartVisibility.urine && (
                                            <Line 
                                                type="monotone" 
                                                dataKey="urine" 
                                                stroke="#10b981" 
                                                strokeWidth={3}
                                                dot={false}
                                                strokeLinecap="round"
                                            />
                                        )}
                                        {chartVisibility.stool && (
                                            <Line 
                                                type="monotone" 
                                                dataKey="stool" 
                                                stroke="#ef4444" 
                                                strokeWidth={3}
                                                dot={false}
                                                strokeLinecap="round"
                                            />
                                        )}
                                    </LineChart>
                                </ResponsiveContainer>
                            </Box>

                            {/* Checkboxes for toggling lines */}
                            <Grid container spacing={2}>
                                {[
                                    { key: 'feeding', label: 'Feeding', color: '#13a4ec' },
                                    { key: 'diaper', label: 'Diaper', color: '#f59e0b' },
                                    { key: 'urine', label: 'Urination', color: '#10b981' },
                                    { key: 'stool', label: 'Defecation', color: '#ef4444' }
                                ].map(line => (
                                    <Grid item xs={6} sm={3} key={line.key}>
                                        <FormControlLabel
                                            control={
                                                <Checkbox
                                                    checked={(chartVisibility as any)[line.key]}
                                                    onChange={() => toggleChartLine(line.key)}
                                                    sx={{
                                                        color: line.color,
                                                        '&.Mui-checked': {
                                                            color: line.color
                                                        }
                                                    }}
                                                />
                                            }
                                            label={
                                                <Typography sx={{ fontSize: '14px', color: '#101c22' }}>
                                                    {line.label}
                                                </Typography>
                                            }
                                        />
                                    </Grid>
                                ))}
                            </Grid>
                        </Card>
                    </Grid>

                    {/* Milk Intake Card */}
                    <Grid item xs={12} sm={6} lg={4}>
                        <Card sx={{
                            bgcolor: '#ffffff',
                            borderRadius: '16px',
                            border: '1px solid #e5e7eb',
                            boxShadow: 'none',
                            p: 3
                        }}>
                            <Typography sx={{ fontSize: '16px', fontWeight: 600, color: '#101c22', mb: 0.5 }}>
                                Milk Intake
                            </Typography>
                            <Typography sx={{ fontSize: '32px', fontWeight: 700, color: '#101c22', mb: 0.5 }}>
                                {totalMilk} ml
                            </Typography>
                            <Typography sx={{ fontSize: '14px', color: '#6b7f8a', mb: 3 }}>
                                {getPeriodLabel()}
                            </Typography>

                            {/* Chart Area */}
                            <Box sx={{ minHeight: '220px' }}>
                                <ResponsiveContainer width="100%" height={220}>
                                    <AreaChart data={chartData} margin={{ top: 10, right: 20, left: -10, bottom: 5 }}>
                                        <defs>
                                            <linearGradient id="colorMilk" x1="0" y1="0" x2="0" y2="1">
                                                <stop offset="0%" stopColor="#13a4ec" stopOpacity={0.2} />
                                                <stop offset="100%" stopColor="#13a4ec" stopOpacity={0} />
                                            </linearGradient>
                                        </defs>
                                        <XAxis 
                                            dataKey="label" 
                                            tick={{ fontSize: 12, fontWeight: 700, fill: '#6b7f8a' }}
                                            axisLine={false}
                                            tickLine={false}
                                        />
                                        <Tooltip 
                                            contentStyle={{
                                                backgroundColor: '#ffffff',
                                                border: '1px solid #e5e7eb',
                                                borderRadius: '8px',
                                                fontSize: '12px'
                                            }}
                                        />
                                        <Area 
                                            type="monotone" 
                                            dataKey="feedingAmount" 
                                            stroke="#13a4ec" 
                                            strokeWidth={3}
                                            fill="url(#colorMilk)"
                                            strokeLinecap="round"
                                        />
                                    </AreaChart>
                                </ResponsiveContainer>
                            </Box>
                        </Card>
                    </Grid>

                    {/* Sleep Duration Card */}
                    <Grid item xs={12} sm={6} lg={4}>
                        <Card sx={{
                            bgcolor: '#ffffff',
                            borderRadius: '16px',
                            border: '1px solid #e5e7eb',
                            boxShadow: 'none',
                            p: 3
                        }}>
                            <Typography sx={{ fontSize: '16px', fontWeight: 600, color: '#101c22', mb: 0.5 }}>
                                Sleep Duration
                            </Typography>
                            <Typography sx={{ fontSize: '32px', fontWeight: 700, color: '#101c22', mb: 0.5 }}>
                                {Math.floor(totalSleep / 60)} hours
                            </Typography>
                            <Typography sx={{ fontSize: '14px', color: '#6b7f8a', mb: 3 }}>
                                {getPeriodLabel()}
                            </Typography>

                            {/* Chart Area */}
                            <Box sx={{ minHeight: '220px' }}>
                                <ResponsiveContainer width="100%" height={220}>
                                    <AreaChart data={chartData} margin={{ top: 10, right: 20, left: -10, bottom: 5 }}>
                                        <defs>
                                            <linearGradient id="colorSleep" x1="0" y1="0" x2="0" y2="1">
                                                <stop offset="0%" stopColor="#13a4ec" stopOpacity={0.2} />
                                                <stop offset="100%" stopColor="#13a4ec" stopOpacity={0} />
                                            </linearGradient>
                                        </defs>
                                        <XAxis 
                                            dataKey="label" 
                                            tick={{ fontSize: 12, fontWeight: 700, fill: '#6b7f8a' }}
                                            axisLine={false}
                                            tickLine={false}
                                        />
                                        <Tooltip 
                                            contentStyle={{
                                                backgroundColor: '#ffffff',
                                                border: '1px solid #e5e7eb',
                                                borderRadius: '8px',
                                                fontSize: '12px'
                                            }}
                                        />
                                        <Area 
                                            type="monotone" 
                                            dataKey="sleep" 
                                            stroke="#13a4ec" 
                                            strokeWidth={3}
                                            fill="url(#colorSleep)"
                                            strokeLinecap="round"
                                        />
                                    </AreaChart>
                                </ResponsiveContainer>
                            </Box>
                        </Card>
                    </Grid>

                    {/* Weight & Height Card */}
                    <Grid item xs={12} sm={6} lg={4}>
                        <Card sx={{
                            bgcolor: '#ffffff',
                            borderRadius: '16px',
                            border: '1px solid #e5e7eb',
                            boxShadow: 'none',
                            p: 3
                        }}>
                            <Typography sx={{ fontSize: '16px', fontWeight: 600, color: '#101c22', mb: 0.5 }}>
                                Weight & Height
                            </Typography>
                            <Typography sx={{ fontSize: '32px', fontWeight: 700, color: '#101c22', mb: 0.5 }}>
                                {latestMeasurement ? `${latestMeasurement.weight || 0} kg, ${latestMeasurement.height || 0} cm` : 'No data'}
                            </Typography>
                            <Typography sx={{ fontSize: '14px', color: '#6b7f8a', mb: 3 }}>
                                {getPeriodLabel()}
                            </Typography>

                            {/* Chart Area */}
                            <Box sx={{ minHeight: '220px' }}>
                                <ResponsiveContainer width="100%" height={220}>
                                    <AreaChart 
                                        data={chartData.filter(d => d.weight || d.height)} 
                                        margin={{ top: 10, right: 20, left: -10, bottom: 5 }}
                                    >
                                        <defs>
                                            <linearGradient id="colorWeight" x1="0" y1="0" x2="0" y2="1">
                                                <stop offset="0%" stopColor="#13a4ec" stopOpacity={0.2} />
                                                <stop offset="100%" stopColor="#13a4ec" stopOpacity={0} />
                                            </linearGradient>
                                        </defs>
                                        <XAxis 
                                            dataKey="label" 
                                            tick={{ fontSize: 12, fontWeight: 700, fill: '#6b7f8a' }}
                                            axisLine={false}
                                            tickLine={false}
                                        />
                                        <Tooltip 
                                            contentStyle={{
                                                backgroundColor: '#ffffff',
                                                border: '1px solid #e5e7eb',
                                                borderRadius: '8px',
                                                fontSize: '12px'
                                            }}
                                        />
                                        <Area 
                                            type="monotone" 
                                            dataKey="weight" 
                                            stroke="#13a4ec" 
                                            strokeWidth={3}
                                            fill="url(#colorWeight)"
                                            strokeLinecap="round"
                                        />
                                    </AreaChart>
                                </ResponsiveContainer>
                            </Box>
                        </Card>
                    </Grid>
                </Grid>
            </Box>
        </Box>
    );
};

export default StatsPage;